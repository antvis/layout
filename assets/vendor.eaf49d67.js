var e=Object.defineProperty,t=Object.assign,n=(t,n,r)=>("symbol"!=typeof n&&(n+=""),n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r),r=function(e){return null!==e&&"object"==typeof e&&"function"==typeof e.addUndirectedEdgeWithKey&&"function"==typeof e.dropNode&&"boolean"==typeof e.multi};function i(e){return"number"!=typeof e||isNaN(e)?1:e}function o(e,t){var n={},r=function(e){return void 0===e?t:e};"function"==typeof t&&(r=t);var i=function(t){return r(t[e])},o=function(){return r(void 0)};return"string"==typeof e?(n.fromAttributes=i,n.fromGraph=function(e,t){return i(e.getEdgeAttributes(t))},n.fromEntry=function(e,t){return i(t)},n.fromPartialEntry=n.fromEntry,n.fromMinimalEntry=n.fromEntry):"function"==typeof e?(n.fromAttributes=function(){throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.")},n.fromGraph=function(t,n){var i=t.extremities(n);return r(e(n,t.getEdgeAttributes(n),i[0],i[1],t.getNodeAttributes(i[0]),t.getNodeAttributes(i[1]),t.isUndirected(n)))},n.fromEntry=function(t,n,i,o,s,a,d){return r(e(t,n,i,o,s,a,d))},n.fromPartialEntry=function(t,n,i,o){return r(e(t,n,i,o))},n.fromMinimalEntry=function(t,n){return r(e(t,n))}):(n.fromAttributes=o,n.fromGraph=o,n.fromEntry=o,n.fromMinimalEntry=o),n}var s=function(e,t,n){var r,i,o,s,a,d,h,u,c,p,l,f,g,y,b,w,m,v,E,k,$,_,G,x=t.length,A=n.length,M=e.adjustSizes,N=e.barnesHutTheta*e.barnesHutTheta,S=[];for(o=0;o<x;o+=10)t[o+4]=t[o+2],t[o+5]=t[o+3],t[o+2]=0,t[o+3]=0;if(e.outboundAttractionDistribution){for(l=0,o=0;o<x;o+=10)l+=t[o+6];l/=x/10}if(e.barnesHutOptimize){var D,L,U,C=1/0,O=-1/0,j=1/0,z=-1/0;for(o=0;o<x;o+=10)C=Math.min(C,t[o+0]),O=Math.max(O,t[o+0]),j=Math.min(j,t[o+1]),z=Math.max(z,t[o+1]);var P=O-C,T=z-j;for(P>T?z=(j-=(P-T)/2)+P:O=(C-=(T-P)/2)+T,S[0]=-1,S[1]=(C+O)/2,S[2]=(j+z)/2,S[3]=Math.max(O-C,z-j),S[4]=-1,S[5]=-1,S[6]=0,S[7]=0,S[8]=0,r=1,o=0;o<x;o+=10)for(i=0,U=3;;){if(!(S[i+5]>=0)){if(S[i+0]<0){S[i+0]=o;break}if(S[i+5]=9*r,u=S[i+3]/2,S[(c=S[i+5])+0]=-1,S[c+1]=S[i+1]-u,S[c+2]=S[i+2]-u,S[c+3]=u,S[c+4]=c+9,S[c+5]=-1,S[c+6]=0,S[c+7]=0,S[c+8]=0,S[(c+=9)+0]=-1,S[c+1]=S[i+1]-u,S[c+2]=S[i+2]+u,S[c+3]=u,S[c+4]=c+9,S[c+5]=-1,S[c+6]=0,S[c+7]=0,S[c+8]=0,S[(c+=9)+0]=-1,S[c+1]=S[i+1]+u,S[c+2]=S[i+2]-u,S[c+3]=u,S[c+4]=c+9,S[c+5]=-1,S[c+6]=0,S[c+7]=0,S[c+8]=0,S[(c+=9)+0]=-1,S[c+1]=S[i+1]+u,S[c+2]=S[i+2]+u,S[c+3]=u,S[c+4]=S[i+4],S[c+5]=-1,S[c+6]=0,S[c+7]=0,S[c+8]=0,r+=4,D=t[S[i+0]+0]<S[i+1]?t[S[i+0]+1]<S[i+2]?S[i+5]:S[i+5]+9:t[S[i+0]+1]<S[i+2]?S[i+5]+18:S[i+5]+27,S[i+6]=t[S[i+0]+6],S[i+7]=t[S[i+0]+0],S[i+8]=t[S[i+0]+1],S[D+0]=S[i+0],S[i+0]=-1,D===(L=t[o+0]<S[i+1]?t[o+1]<S[i+2]?S[i+5]:S[i+5]+9:t[o+1]<S[i+2]?S[i+5]+18:S[i+5]+27)){if(U--){i=D;continue}U=3;break}S[L+0]=o;break}D=t[o+0]<S[i+1]?t[o+1]<S[i+2]?S[i+5]:S[i+5]+9:t[o+1]<S[i+2]?S[i+5]+18:S[i+5]+27,S[i+7]=(S[i+7]*S[i+6]+t[o+0]*t[o+6])/(S[i+6]+t[o+6]),S[i+8]=(S[i+8]*S[i+6]+t[o+1]*t[o+6])/(S[i+6]+t[o+6]),S[i+6]+=t[o+6],i=D}}if(e.barnesHutOptimize){for(f=e.scalingRatio,o=0;o<x;o+=10)for(i=0;;)if(S[i+5]>=0){if(w=Math.pow(t[o+0]-S[i+7],2)+Math.pow(t[o+1]-S[i+8],2),4*(p=S[i+3])*p/w<N){if(g=t[o+0]-S[i+7],y=t[o+1]-S[i+8],!0===M?w>0?(m=f*t[o+6]*S[i+6]/w,t[o+2]+=g*m,t[o+3]+=y*m):w<0&&(m=-f*t[o+6]*S[i+6]/Math.sqrt(w),t[o+2]+=g*m,t[o+3]+=y*m):w>0&&(m=f*t[o+6]*S[i+6]/w,t[o+2]+=g*m,t[o+3]+=y*m),(i=S[i+4])<0)break;continue}i=S[i+5]}else if((d=S[i+0])>=0&&d!==o&&(w=(g=t[o+0]-t[d+0])*g+(y=t[o+1]-t[d+1])*y,!0===M?w>0?(m=f*t[o+6]*t[d+6]/w,t[o+2]+=g*m,t[o+3]+=y*m):w<0&&(m=-f*t[o+6]*t[d+6]/Math.sqrt(w),t[o+2]+=g*m,t[o+3]+=y*m):w>0&&(m=f*t[o+6]*t[d+6]/w,t[o+2]+=g*m,t[o+3]+=y*m)),(i=S[i+4])<0)break}else for(f=e.scalingRatio,s=0;s<x;s+=10)for(a=0;a<s;a+=10)g=t[s+0]-t[a+0],y=t[s+1]-t[a+1],!0===M?(w=Math.sqrt(g*g+y*y)-t[s+8]-t[a+8])>0?(m=f*t[s+6]*t[a+6]/w/w,t[s+2]+=g*m,t[s+3]+=y*m,t[a+2]-=g*m,t[a+3]-=y*m):w<0&&(m=100*f*t[s+6]*t[a+6],t[s+2]+=g*m,t[s+3]+=y*m,t[a+2]-=g*m,t[a+3]-=y*m):(w=Math.sqrt(g*g+y*y))>0&&(m=f*t[s+6]*t[a+6]/w/w,t[s+2]+=g*m,t[s+3]+=y*m,t[a+2]-=g*m,t[a+3]-=y*m);for(c=e.gravity/e.scalingRatio,f=e.scalingRatio,o=0;o<x;o+=10)m=0,g=t[o+0],y=t[o+1],w=Math.sqrt(Math.pow(g,2)+Math.pow(y,2)),e.strongGravityMode?w>0&&(m=f*t[o+6]*c):w>0&&(m=f*t[o+6]*c/w),t[o+2]-=g*m,t[o+3]-=y*m;for(f=1*(e.outboundAttractionDistribution?l:1),h=0;h<A;h+=3)s=n[h+0],a=n[h+1],u=n[h+2],b=Math.pow(u,e.edgeWeightInfluence),g=t[s+0]-t[a+0],y=t[s+1]-t[a+1],!0===M?(w=Math.sqrt(g*g+y*y)-t[s+8]-t[a+8],e.linLogMode?e.outboundAttractionDistribution?w>0&&(m=-f*b*Math.log(1+w)/w/t[s+6]):w>0&&(m=-f*b*Math.log(1+w)/w):e.outboundAttractionDistribution?w>0&&(m=-f*b/t[s+6]):w>0&&(m=-f*b)):(w=Math.sqrt(Math.pow(g,2)+Math.pow(y,2)),e.linLogMode?e.outboundAttractionDistribution?w>0&&(m=-f*b*Math.log(1+w)/w/t[s+6]):w>0&&(m=-f*b*Math.log(1+w)/w):e.outboundAttractionDistribution?(w=1,m=-f*b/t[s+6]):(w=1,m=-f*b)),w>0&&(t[s+2]+=g*m,t[s+3]+=y*m,t[a+2]-=g*m,t[a+3]-=y*m);if(!0===M)for(o=0;o<x;o+=10)1!==t[o+9]&&((v=Math.sqrt(Math.pow(t[o+2],2)+Math.pow(t[o+3],2)))>10&&(t[o+2]=10*t[o+2]/v,t[o+3]=10*t[o+3]/v),E=t[o+6]*Math.sqrt((t[o+4]-t[o+2])*(t[o+4]-t[o+2])+(t[o+5]-t[o+3])*(t[o+5]-t[o+3])),k=Math.sqrt((t[o+4]+t[o+2])*(t[o+4]+t[o+2])+(t[o+5]+t[o+3])*(t[o+5]+t[o+3]))/2,$=.1*Math.log(1+k)/(1+Math.sqrt(E)),_=t[o+0]+t[o+2]*($/e.slowDown),t[o+0]=_,G=t[o+1]+t[o+3]*($/e.slowDown),t[o+1]=G);else for(o=0;o<x;o+=10)1!==t[o+9]&&(E=t[o+6]*Math.sqrt((t[o+4]-t[o+2])*(t[o+4]-t[o+2])+(t[o+5]-t[o+3])*(t[o+5]-t[o+3])),k=Math.sqrt((t[o+4]+t[o+2])*(t[o+4]+t[o+2])+(t[o+5]+t[o+3])*(t[o+5]+t[o+3]))/2,$=t[o+7]*Math.log(1+k)/(1+Math.sqrt(E)),t[o+7]=Math.min(1,Math.sqrt($*(Math.pow(t[o+2],2)+Math.pow(t[o+3],2))/(1+Math.sqrt(E)))),_=t[o+0]+t[o+2]*($/e.slowDown),t[o+0]=_,G=t[o+1]+t[o+3]*($/e.slowDown),t[o+1]=G);return{}},a=function(e){e=e||{};var t,n,r,i=Array.prototype.slice.call(arguments).slice(1);for(t=0,r=i.length;t<r;t++)if(i[t])for(n in i[t])e[n]=i[t][n];return e},d=function(e){return"linLogMode"in e&&"boolean"!=typeof e.linLogMode?{message:"the `linLogMode` setting should be a boolean."}:"outboundAttractionDistribution"in e&&"boolean"!=typeof e.outboundAttractionDistribution?{message:"the `outboundAttractionDistribution` setting should be a boolean."}:"adjustSizes"in e&&"boolean"!=typeof e.adjustSizes?{message:"the `adjustSizes` setting should be a boolean."}:"edgeWeightInfluence"in e&&"number"!=typeof e.edgeWeightInfluence?{message:"the `edgeWeightInfluence` setting should be a number."}:!("scalingRatio"in e)||"number"==typeof e.scalingRatio&&e.scalingRatio>=0?"strongGravityMode"in e&&"boolean"!=typeof e.strongGravityMode?{message:"the `strongGravityMode` setting should be a boolean."}:!("gravity"in e)||"number"==typeof e.gravity&&e.gravity>=0?"slowDown"in e&&!("number"==typeof e.slowDown||e.slowDown>=0)?{message:"the `slowDown` setting should be a number >= 0."}:"barnesHutOptimize"in e&&"boolean"!=typeof e.barnesHutOptimize?{message:"the `barnesHutOptimize` setting should be a boolean."}:!("barnesHutTheta"in e)||"number"==typeof e.barnesHutTheta&&e.barnesHutTheta>=0?null:{message:"the `barnesHutTheta` setting should be a number >= 0."}:{message:"the `gravity` setting should be a number >= 0."}:{message:"the `scalingRatio` setting should be a number >= 0."}},h=function(e,t){var n,r=e.order,i=e.size,o={},s=new Float32Array(10*r),a=new Float32Array(3*i);return n=0,e.forEachNode((function(e,t){o[e]=n,s[n]=t.x,s[n+1]=t.y,s[n+2]=0,s[n+3]=0,s[n+4]=0,s[n+5]=0,s[n+6]=1,s[n+7]=1,s[n+8]=t.size||1,s[n+9]=t.fixed?1:0,n+=10})),n=0,e.forEachEdge((function(e,r,i,d,h,u,c){var p=o[i],l=o[d],f=t(e,r,i,d,h,u,c);s[p+6]+=f,s[l+6]+=f,a[n]=p,a[n+1]=l,a[n+2]=f,n+=3})),{nodes:s,edges:a}},u=function(e,t,n){var r=0;e.updateEachNodeAttributes((function(e,i){return i.x=t[r],i.y=t[r+1],r+=10,n?n(e,i):i}))},c=function(e,t,n){for(var r=e.nodes(),i={},o=0,s=0,a=t.length;o<a;o+=10){if(n){var d=Object.assign({},e.getNodeAttributes(r[s]));d.x=t[o],d.y=t[o+1],d=n(r[s],d),i[r[s]]={x:d.x,y:d.y}}else i[r[s]]={x:t[o],y:t[o+1]};s++}return i},p={linLogMode:!1,outboundAttractionDistribution:!1,adjustSizes:!1,edgeWeightInfluence:1,scalingRatio:1,strongGravityMode:!1,gravity:1,slowDown:1,barnesHutOptimize:!1,barnesHutTheta:.5},l=function(e){return o(e,i)};function f(e,t,n){if(!r(t))throw new Error("graphology-layout-forceatlas2: the given graph is not a valid graphology instance.");"number"==typeof n&&(n={iterations:n});var i=n.iterations;if("number"!=typeof i)throw new Error("graphology-layout-forceatlas2: invalid number of iterations.");if(i<=0)throw new Error("graphology-layout-forceatlas2: you should provide a positive number of iterations.");var o=l("getEdgeWeight"in n?n.getEdgeWeight:"weight").fromEntry,f="function"==typeof n.outputReducer?n.outputReducer:null,g=a({},p,n.settings),y=d(g);if(y)throw new Error("graphology-layout-forceatlas2: "+y.message);var b,w=h(t,o);for(b=0;b<i;b++)s(g,w.nodes,w.edges);if(!e)return c(t,w.nodes);u(t,w.nodes,f)}var g=f.bind(null,!1);g.assign=f.bind(null,!0),g.inferSettings=function(e){var t="number"==typeof e?e:e.order;return{barnesHutOptimize:t>2e3,strongGravityMode:!0,gravity:.05,scalingRatio:10,slowDown:1+Math.log(t)}};var y=g,b=function(){return(b=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function w(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{d(r.next(e))}catch(t){o(t)}}function a(e){try{d(r.throw(e))}catch(t){o(t)}}function d(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}d((r=r.apply(e,t||[])).next())}))}function m(e,t){var n,r,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(a){return function(d){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;o&&(o=0,a[0]&&(s=0)),s;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,r=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!(i=s.trys,(i=i.length>0&&i[i.length-1])||6!==a[0]&&2!==a[0])){s=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){s.label=a[1];break}if(6===a[0]&&s.label<i[1]){s.label=i[1],i=a;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(a);break}i[2]&&s.ops.pop(),s.trys.pop();continue}a=t.call(e,s)}catch(d){a=[6,d],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,d])}}}const v=Symbol("Comlink.proxy"),E=Symbol("Comlink.endpoint"),k=Symbol("Comlink.releaseProxy"),$=Symbol("Comlink.thrown"),_=e=>"object"==typeof e&&null!==e||"function"==typeof e,G=new Map([["proxy",{canHandle:e=>_(e)&&e[v],serialize(e){const{port1:t,port2:n}=new MessageChannel;return x(e,t),[n,[n]]},deserialize:e=>(e.start(),M(e))}],["throw",{canHandle:e=>_(e)&&$ in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function x(e,t=self){t.addEventListener("message",(function n(r){if(!r||!r.data)return;const{id:i,type:o,path:s}=Object.assign({path:[]},r.data),a=(r.data.argumentList||[]).map(C);let d;try{const t=s.slice(0,-1).reduce(((e,t)=>e[t]),e),n=s.reduce(((e,t)=>e[t]),e);switch(o){case"GET":d=n;break;case"SET":t[s.slice(-1)[0]]=C(r.data.value),d=!0;break;case"APPLY":d=n.apply(t,a);break;case"CONSTRUCT":d=function(e){return Object.assign(e,{[v]:!0})}(new n(...a));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;x(e,n),d=function(e,t){return L.set(e,t),e}(t,[t])}break;case"RELEASE":d=void 0;break;default:return}}catch(h){d={value:h,[$]:0}}Promise.resolve(d).catch((e=>({value:e,[$]:0}))).then((e=>{const[r,s]=U(e);t.postMessage(Object.assign(Object.assign({},r),{id:i}),s),"RELEASE"===o&&(t.removeEventListener("message",n),A(t))}))})),t.start&&t.start()}function A(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function M(e,t){return S(e,[],t)}function N(e){if(e)throw new Error("Proxy has been released and is not useable")}function S(e,t=[],n=function(){}){let r=!1;const i=new Proxy(n,{get(n,o){if(N(r),o===k)return()=>O(e,{type:"RELEASE",path:t.map((e=>e.toString()))}).then((()=>{A(e),r=!0}));if("then"===o){if(0===t.length)return{then:()=>i};const n=O(e,{type:"GET",path:t.map((e=>e.toString()))}).then(C);return n.then.bind(n)}return S(e,[...t,o])},set(n,i,o){N(r);const[s,a]=U(o);return O(e,{type:"SET",path:[...t,i].map((e=>e.toString())),value:s},a).then(C)},apply(n,i,o){N(r);const s=t[t.length-1];if(s===E)return O(e,{type:"ENDPOINT"}).then(C);if("bind"===s)return S(e,t.slice(0,-1));const[a,d]=D(o);return O(e,{type:"APPLY",path:t.map((e=>e.toString())),argumentList:a},d).then(C)},construct(n,i){N(r);const[o,s]=D(i);return O(e,{type:"CONSTRUCT",path:t.map((e=>e.toString())),argumentList:o},s).then(C)}});return i}function D(e){const t=e.map(U);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const L=new WeakMap;function U(e){for(const[t,n]of G)if(n.canHandle(e)){const[r,i]=n.serialize(e);return[{type:"HANDLER",name:t,value:r},i]}return[{type:"RAW",value:e},L.get(e)||[]]}function C(e){switch(e.type){case"HANDLER":return G.get(e.name).deserialize(e.value);case"RAW":return e.value}}function O(e,t,n){return new Promise((r=>{const i=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===i&&(e.removeEventListener("message",t),r(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:i},t),n)}))}var j,z={}.toString,P=function(e,t){return z.call(e)==="[object "+t+"]"},T=function(e){return P(e,"Number")},R="object"==typeof Reflect?Reflect:null,W=R&&"function"==typeof R.apply?R.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};j=R&&"function"==typeof R.ownKeys?R.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var I=Number.isNaN||function(e){return e!=e};function K(){K.init.call(this)}var H=K,q=function(e,t){return new Promise((function(n,r){function i(n){e.removeListener(t,o),r(n)}function o(){"function"==typeof e.removeListener&&e.removeListener("error",i),n([].slice.call(arguments))}te(e,t,o,{once:!0}),"error"!==t&&function(e,t,n){"function"==typeof e.on&&te(e,"error",t,n)}(e,i,{once:!0})}))};K.EventEmitter=K,K.prototype._events=void 0,K.prototype._eventsCount=0,K.prototype._maxListeners=void 0;var V=10;function F(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function Y(e){return void 0===e._maxListeners?K.defaultMaxListeners:e._maxListeners}function B(e,t,n,r){var i,o,s,a;if(F(n),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),o=e._events),s=o[t]),void 0===s)s=o[t]=n,++e._eventsCount;else if("function"==typeof s?s=o[t]=r?[n,s]:[s,n]:r?s.unshift(n):s.push(n),(i=Y(e))>0&&s.length>i&&!s.warned){s.warned=!0;var d=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");d.name="MaxListenersExceededWarning",d.emitter=e,d.type=t,d.count=s.length,a=d,console&&console.warn&&console.warn(a)}return e}function J(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function X(e,t,n){var r={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},i=J.bind(r);return i.listener=n,r.wrapFn=i,i}function Q(e,t,n){var r=e._events;if(void 0===r)return[];var i=r[t];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(i):ee(i,i.length)}function Z(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function ee(e,t){for(var n=new Array(t),r=0;r<t;++r)n[r]=e[r];return n}function te(e,t,n,r){if("function"==typeof e.on)r.once?e.once(t,n):e.on(t,n);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function i(o){r.once&&e.removeEventListener(t,i),n(o)}))}}function ne(e){if("function"!=typeof e)throw new Error("obliterator/iterator: expecting a function!");this.next=e}Object.defineProperty(K,"defaultMaxListeners",{enumerable:!0,get:function(){return V},set:function(e){if("number"!=typeof e||e<0||I(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");V=e}}),K.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},K.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||I(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},K.prototype.getMaxListeners=function(){return Y(this)},K.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var r="error"===e,i=this._events;if(void 0!==i)r=r&&void 0===i.error;else if(!r)return!1;if(r){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var s=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw s.context=o,s}var a=i[e];if(void 0===a)return!1;if("function"==typeof a)W(a,this,t);else{var d=a.length,h=ee(a,d);for(n=0;n<d;++n)W(h[n],this,t)}return!0},K.prototype.addListener=function(e,t){return B(this,e,t,!1)},K.prototype.on=K.prototype.addListener,K.prototype.prependListener=function(e,t){return B(this,e,t,!0)},K.prototype.once=function(e,t){return F(t),this.on(e,X(this,e,t)),this},K.prototype.prependOnceListener=function(e,t){return F(t),this.prependListener(e,X(this,e,t)),this},K.prototype.removeListener=function(e,t){var n,r,i,o,s;if(F(t),void 0===(r=this._events))return this;if(void 0===(n=r[e]))return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(i=-1,o=n.length-1;o>=0;o--)if(n[o]===t||n[o].listener===t){s=n[o].listener,i=o;break}if(i<0)return this;0===i?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,i),1===n.length&&(r[e]=n[0]),void 0!==r.removeListener&&this.emit("removeListener",e,s||t)}return this},K.prototype.off=K.prototype.removeListener,K.prototype.removeAllListeners=function(e){var t,n,r;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var i,o=Object.keys(n);for(r=0;r<o.length;++r)"removeListener"!==(i=o[r])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(r=t.length-1;r>=0;r--)this.removeListener(e,t[r]);return this},K.prototype.listeners=function(e){return Q(this,e,!0)},K.prototype.rawListeners=function(e){return Q(this,e,!1)},K.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):Z.call(e,t)},K.prototype.listenerCount=Z,K.prototype.eventNames=function(){return this._eventsCount>0?j(this._events):[]},H.once=q,"undefined"!=typeof Symbol&&(ne.prototype[Symbol.iterator]=function(){return this}),ne.of=function(){var e=arguments,t=e.length,n=0;return new ne((function(){return n>=t?{done:!0}:{done:!1,value:e[n++]}}))},ne.empty=function(){return new ne((function(){return{done:!0}}))},ne.fromSequence=function(e){var t=0,n=e.length;return new ne((function(){return t>=n?{done:!0}:{done:!1,value:e[t++]}}))},ne.is=function(e){return e instanceof ne||"object"==typeof e&&null!==e&&"function"==typeof e.next};var re=ne,ie={ARRAY_BUFFER_SUPPORT:"undefined"!=typeof ArrayBuffer,SYMBOL_SUPPORT:"undefined"!=typeof Symbol},oe=ie.ARRAY_BUFFER_SUPPORT,se=ie.SYMBOL_SUPPORT;var ae=function(e){var t=function(e){return"string"==typeof e||Array.isArray(e)||oe&&ArrayBuffer.isView(e)?re.fromSequence(e):"object"!=typeof e||null===e?null:se&&"function"==typeof e[Symbol.iterator]?e[Symbol.iterator]():"function"==typeof e.next?e:null}(e);if(!t)throw new Error("obliterator: target is not iterable nor a valid iterator.");return t},de=function(e,t){for(var n,r=arguments.length>1?t:1/0,i=r!==1/0?new Array(r):[],o=0,s=ae(e);;){if(o===r)return i;if((n=s.next()).done)return o!==t&&(i.length=o),i;i[o++]=n.value}},he=function(){var e=arguments,t=null,n=-1;return new re((function(){for(var r=null;;){if(null===t){if(++n>=e.length)return{done:!0};t=ae(e[n])}if(!0!==(r=t.next()).done)break;t=null}return r}))};let ue=function(){const e=arguments[0];for(let t=1,n=arguments.length;t<n;t++)if(arguments[t])for(const r in arguments[t])e[r]=arguments[t][r];return e};function ce(e,t,n,r){const i=e._nodes.get(t);let o=null;return i?(o="mixed"===r?i.out&&i.out[n]||i.undirected&&i.undirected[n]:"directed"===r?i.out&&i.out[n]:i.undirected&&i.undirected[n],o):o}function pe(e){return"object"==typeof e&&null!==e&&e.constructor===Object}function le(e){let t;for(t in e)return!1;return!0}function fe(e,t,n){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:n})}function ge(e,t,n){const r={enumerable:!0,configurable:!0};"function"==typeof n?r.get=n:(r.value=n,r.writable=!1),Object.defineProperty(e,t,r)}function ye(e){return!!pe(e)&&!(e.attributes&&!Array.isArray(e.attributes))}"function"==typeof Object.assign&&(ue=Object.assign);class be extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class we extends be{constructor(e){super(e),this.name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,we.prototype.constructor)}}class me extends be{constructor(e){super(e),this.name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,me.prototype.constructor)}}class ve extends be{constructor(e){super(e),this.name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,ve.prototype.constructor)}}function Ee(e,t){this.key=e,this.attributes=t,this.clear()}function ke(e,t){this.key=e,this.attributes=t,this.clear()}function $e(e,t){this.key=e,this.attributes=t,this.clear()}function _e(e,t,n,r,i){this.key=t,this.attributes=i,this.undirected=e,this.source=n,this.target=r}Ee.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},ke.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},$e.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},_e.prototype.attach=function(){let e="out",t="in";this.undirected&&(e=t="undirected");const n=this.source.key,r=this.target.key;this.source[e][r]=this,this.undirected&&n===r||(this.target[t][n]=this)},_e.prototype.attachMulti=function(){let e="out",t="in";const n=this.source.key,r=this.target.key;this.undirected&&(e=t="undirected");const i=this.source[e],o=i[r];if(void 0===o)return i[r]=this,void(this.undirected&&n===r||(this.target[t][n]=this));o.previous=this,this.next=o,i[r]=this,this.target[t][n]=this},_e.prototype.detach=function(){const e=this.source.key,t=this.target.key;let n="out",r="in";this.undirected&&(n=r="undirected"),delete this.source[n][t],delete this.target[r][e]},_e.prototype.detachMulti=function(){const e=this.source.key,t=this.target.key;let n="out",r="in";this.undirected&&(n=r="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[n][t],delete this.target[r][e]):(this.next.previous=void 0,this.source[n][t]=this.next,this.target[r][e]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};function Ge(e,t,n,r,i,o,s){let a,d,h,u;if(r=""+r,0===n){if(a=e._nodes.get(r),!a)throw new me(`Graph.${t}: could not find the "${r}" node in the graph.`);h=i,u=o}else if(3===n){if(i=""+i,d=e._edges.get(i),!d)throw new me(`Graph.${t}: could not find the "${i}" edge in the graph.`);const n=d.source.key,c=d.target.key;if(r===n)a=d.target;else{if(r!==c)throw new me(`Graph.${t}: the "${r}" node is not attached to the "${i}" edge (${n}, ${c}).`);a=d.source}h=o,u=s}else{if(d=e._edges.get(r),!d)throw new me(`Graph.${t}: could not find the "${r}" edge in the graph.`);a=1===n?d.source:d.target,h=i,u=o}return[a,h,u]}const xe=[{name:e=>`get${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Ge(this,t,n,e,r,i);return o.attributes[s]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r){const[i]=Ge(this,t,n,e,r);return i.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Ge(this,t,n,e,r,i);return o.attributes.hasOwnProperty(s)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i,o){const[s,a,d]=Ge(this,t,n,e,r,i,o);return s.attributes[a]=d,this.emit("nodeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:a}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i,o){const[s,a,d]=Ge(this,t,n,e,r,i,o);if("function"!=typeof d)throw new we(`Graph.${t}: updater should be a function.`);const h=s.attributes,u=d(h[a]);return h[a]=u,this.emit("nodeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:a}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Ge(this,t,n,e,r,i);return delete o.attributes[s],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:s}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Ge(this,t,n,e,r,i);if(!pe(s))throw new we(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=s,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Ge(this,t,n,e,r,i);if(!pe(s))throw new we(`Graph.${t}: provided attributes are not a plain object.`);return ue(o.attributes,s),this.emit("nodeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:s}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){const[o,s]=Ge(this,t,n,e,r,i);if("function"!=typeof s)throw new we(`Graph.${t}: provided updater is not a function.`);return o.attributes=s(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}];const Ae=[{name:e=>`get${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=ce(this,o,s,n),!i)throw new me(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return i.attributes[r]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e){let r;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const i=""+e,o=""+arguments[1];if(r=ce(this,i,o,n),!r)throw new me(`Graph.${t}: could not find an edge for the given path ("${i}" - "${o}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return r.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=ce(this,o,s,n),!i)throw new me(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return i.attributes.hasOwnProperty(r)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){let o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+e,a=""+r;if(r=arguments[2],i=arguments[3],o=ce(this,s,a,n),!o)throw new me(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,o=this._edges.get(e),!o)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return o.attributes[r]=i,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r,i){let o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+e,a=""+r;if(r=arguments[2],i=arguments[3],o=ce(this,s,a,n),!o)throw new me(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,o=this._edges.get(e),!o)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof i)throw new we(`Graph.${t}: updater should be a function.`);return o.attributes[r]=i(o.attributes[r]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=ce(this,o,s,n),!i)throw new me(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return delete i.attributes[r],this.emit("edgeAttributesUpdated",{key:i.key,type:"remove",attributes:i.attributes,name:r}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=ce(this,o,s,n),!i)throw new me(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!pe(r))throw new we(`Graph.${t}: provided attributes are not a plain object.`);return i.attributes=r,this.emit("edgeAttributesUpdated",{key:i.key,type:"replace",attributes:i.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=ce(this,o,s,n),!i)throw new me(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!pe(r))throw new we(`Graph.${t}: provided attributes are not a plain object.`);return ue(i.attributes,r),this.emit("edgeAttributesUpdated",{key:i.key,type:"merge",attributes:i.attributes,data:r}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,n){e.prototype[t]=function(e,r){let i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new ve(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new ve(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+e,s=""+r;if(r=arguments[2],i=ce(this,o,s,n),!i)throw new me(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if("mixed"!==n)throw new ve(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new me(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof r)throw new we(`Graph.${t}: provided updater is not a function.`);return i.attributes=r(i.attributes),this.emit("edgeAttributesUpdated",{key:i.key,type:"update",attributes:i.attributes}),this}}}];const Me=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function Ne(e,t,n,r){let i=!1;for(const o in t){if(o===r)continue;const s=t[o];if(i=n(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),e&&i)return s.key}}function Se(e,t,n,r){let i,o,s,a=!1;for(const d in t)if(d!==r){i=t[d];do{if(o=i.source,s=i.target,a=n(i.key,i.attributes,o.key,s.key,o.attributes,s.attributes,i.undirected),e&&a)return i.key;i=i.next}while(void 0!==i)}}function De(e,t){const n=Object.keys(e),r=n.length;let i,o=0;return new re((function(){do{if(i)i=i.next;else{if(o>=r)return{done:!0};const s=n[o++];if(s===t){i=void 0;continue}i=e[s]}}while(!i);return{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}}}))}function Le(e,t,n,r){const i=t[n];if(!i)return;const o=i.source,s=i.target;return r(i.key,i.attributes,o.key,s.key,o.attributes,s.attributes,i.undirected)&&e?i.key:void 0}function Ue(e,t,n,r){let i=t[n];if(!i)return;let o=!1;do{if(o=r(i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,i.target.attributes,i.undirected),e&&o)return i.key;i=i.next}while(void 0!==i)}function Ce(e,t){let n=e[t];return void 0!==n.next?new re((function(){if(!n)return{done:!0};const e={edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected};return n=n.next,{done:!1,value:e}})):re.of({edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected})}function Oe(e,t){if(0===e.size)return[];if("mixed"===t||t===e.type)return"function"==typeof Array.from?Array.from(e._edges.keys()):de(e._edges.keys(),e._edges.size);const n="undirected"===t?e.undirectedSize:e.directedSize,r=new Array(n),i="undirected"===t,o=e._edges.values();let s,a,d=0;for(;s=o.next(),!0!==s.done;)a=s.value,a.undirected===i&&(r[d++]=a.key);return r}function je(e,t,n,r){if(0===t.size)return;const i="mixed"!==n&&n!==t.type,o="undirected"===n;let s,a,d=!1;const h=t._edges.values();for(;s=h.next(),!0!==s.done;){if(a=s.value,i&&a.undirected!==o)continue;const{key:t,attributes:n,source:h,target:u}=a;if(d=r(t,n,h.key,u.key,h.attributes,u.attributes,a.undirected),e&&d)return t}}function ze(e,t){if(0===e.size)return re.empty();const n="mixed"!==t&&t!==e.type,r="undirected"===t,i=e._edges.values();return new re((function(){let e,t;for(;;){if(e=i.next(),e.done)return e;if(t=e.value,!n||t.undirected===r)break}return{value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected},done:!1}}))}function Pe(e,t,n,r,i,o){const s=t?Se:Ne;let a;if("undirected"!==n){if("out"!==r&&(a=s(e,i.in,o),e&&a))return a;if("in"!==r&&(a=s(e,i.out,o,r?void 0:i.key),e&&a))return a}if("directed"!==n&&(a=s(e,i.undirected,o),e&&a))return a}function Te(e,t,n,r){const i=[];return Pe(!1,e,t,n,r,(function(e){i.push(e)})),i}function Re(e,t,n){let r=re.empty();return"undirected"!==e&&("out"!==t&&void 0!==n.in&&(r=he(r,De(n.in))),"in"!==t&&void 0!==n.out&&(r=he(r,De(n.out,t?void 0:n.key)))),"directed"!==e&&void 0!==n.undirected&&(r=he(r,De(n.undirected))),r}function We(e,t,n,r,i,o,s){const a=n?Ue:Le;let d;if("undirected"!==t){if(void 0!==i.in&&"out"!==r&&(d=a(e,i.in,o,s),e&&d))return d;if(void 0!==i.out&&"in"!==r&&(r||i.key!==o)&&(d=a(e,i.out,o,s),e&&d))return d}if("directed"!==t&&void 0!==i.undirected&&(d=a(e,i.undirected,o,s),e&&d))return d}function Ie(e,t,n,r,i){const o=[];return We(!1,e,t,n,r,i,(function(e){o.push(e)})),o}function Ke(e,t,n,r){let i=re.empty();return"undirected"!==e&&(void 0!==n.in&&"out"!==t&&r in n.in&&(i=he(i,Ce(n.in,r))),void 0!==n.out&&"in"!==t&&r in n.out&&(t||n.key!==r)&&(i=he(i,Ce(n.out,r)))),"directed"!==e&&void 0!==n.undirected&&r in n.undirected&&(i=he(i,Ce(n.undirected,r))),i}const He=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function qe(){this.A=null,this.B=null}function Ve(e,t,n,r,i){for(const o in r){const s=r[o],a=s.source,d=s.target,h=a===n?d:a;if(t&&t.has(h.key))continue;const u=i(h.key,h.attributes);if(e&&u)return h.key}}function Fe(e,t,n,r,i){if("mixed"!==t){if("undirected"===t)return Ve(e,null,r,r.undirected,i);if("string"==typeof n)return Ve(e,null,r,r[n],i)}const o=new qe;let s;if("undirected"!==t){if("out"!==n){if(s=Ve(e,null,r,r.in,i),e&&s)return s;o.wrap(r.in)}if("in"!==n){if(s=Ve(e,o,r,r.out,i),e&&s)return s;o.wrap(r.out)}}if("directed"!==t&&(s=Ve(e,o,r,r.undirected,i),e&&s))return s}function Ye(e,t,n){const r=Object.keys(n),i=r.length;let o=0;return new re((function(){let s=null;do{if(o>=i)return e&&e.wrap(n),{done:!0};const a=n[r[o++]],d=a.source,h=a.target;s=d===t?h:d,e&&e.has(s.key)&&(s=null)}while(null===s);return{done:!1,value:{neighbor:s.key,attributes:s.attributes}}}))}function Be(e,t){const{name:n,type:r,direction:i}=t;e.prototype[n]=function(e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new me(`Graph.${n}: could not find the "${e}" node in the graph.`);return function(e,t,n){if("mixed"!==e){if("undirected"===e)return Object.keys(n.undirected);if("string"==typeof t)return Object.keys(n[t])}const r=[];return Fe(!1,e,t,n,(function(e){r.push(e)})),r}("mixed"===r?this.type:r,i,t)}}function Je(e,t){const{name:n,type:r,direction:i}=t,o=n.slice(0,-1)+"Entries";e.prototype[o]=function(e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return re.empty();e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new me(`Graph.${o}: could not find the "${e}" node in the graph.`);return function(e,t,n){if("mixed"!==e){if("undirected"===e)return Ye(null,n,n.undirected);if("string"==typeof t)return Ye(null,n,n[t])}let r=re.empty();const i=new qe;return"undirected"!==e&&("out"!==t&&(r=he(r,Ye(i,n,n.in))),"in"!==t&&(r=he(r,Ye(i,n,n.out)))),"directed"!==e&&(r=he(r,Ye(i,n,n.undirected))),r}("mixed"===r?this.type:r,i,t)}}function Xe(e,t,n,r,i){const o=r._nodes.values(),s=r.type;let a,d,h,u,c,p,l;for(;a=o.next(),!0!==a.done;){let r=!1;if(d=a.value,"undirected"!==s)for(h in u=d.out,u){c=u[h];do{if(p=c.target,r=!0,l=i(d.key,p.key,d.attributes,p.attributes,c.key,c.attributes,c.undirected),e&&l)return c;c=c.next}while(c)}if("directed"!==s)for(h in u=d.undirected,u)if(!(t&&d.key>h)){c=u[h];do{if(p=c.target,p.key!==h&&(p=c.source),r=!0,l=i(d.key,p.key,d.attributes,p.attributes,c.key,c.attributes,c.undirected),e&&l)return c;c=c.next}while(c)}if(n&&!r&&(l=i(d.key,null,d.attributes,null,null,null,null),e&&l))return null}}function Qe(e){if(!pe(e))throw new we('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in e))throw new we("Graph.import: serialized node is missing its key.");if("attributes"in e&&(!pe(e.attributes)||null===e.attributes))throw new we("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Ze(e){if(!pe(e))throw new we('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in e))throw new we("Graph.import: serialized edge is missing its source.");if(!("target"in e))throw new we("Graph.import: serialized edge is missing its target.");if("attributes"in e&&(!pe(e.attributes)||null===e.attributes))throw new we("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in e&&"boolean"!=typeof e.undirected)throw new we("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}qe.prototype.wrap=function(e){null===this.A?this.A=e:null===this.B&&(this.B=e)},qe.prototype.has=function(e){return null!==this.A&&e in this.A||null!==this.B&&e in this.B};const et=function(){let e=255&Math.floor(256*Math.random());return()=>e++}(),tt=new Set(["directed","undirected","mixed"]),nt=new Set(["domain","_events","_eventsCount","_maxListeners"]),rt={allowSelfLoops:!0,multi:!1,type:"mixed"};function it(e,t,n){const r=new e.NodeDataClass(t,n);return e._nodes.set(t,r),e.emit("nodeAdded",{key:t,attributes:n}),r}function ot(e,t,n,r,i,o,s,a){if(!r&&"undirected"===e.type)throw new ve(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(r&&"directed"===e.type)throw new ve(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!pe(a))throw new we(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);if(o=""+o,s=""+s,a=a||{},!e.allowSelfLoops&&o===s)throw new ve(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const d=e._nodes.get(o),h=e._nodes.get(s);if(!d)throw new me(`Graph.${t}: source node "${o}" not found.`);if(!h)throw new me(`Graph.${t}: target node "${s}" not found.`);const u={key:null,undirected:r,source:o,target:s,attributes:a};if(n)i=e._edgeKeyGenerator();else if(i=""+i,e._edges.has(i))throw new ve(`Graph.${t}: the "${i}" edge already exists in the graph.`);if(!e.multi&&(r?void 0!==d.undirected[s]:void 0!==d.out[s]))throw new ve(`Graph.${t}: an edge linking "${o}" to "${s}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const c=new _e(r,i,d,h,a);e._edges.set(i,c);const p=o===s;return r?(d.undirectedDegree++,h.undirectedDegree++,p&&(d.undirectedLoops++,e._undirectedSelfLoopCount++)):(d.outDegree++,h.inDegree++,p&&(d.directedLoops++,e._directedSelfLoopCount++)),e.multi?c.attachMulti():c.attach(),r?e._undirectedSize++:e._directedSize++,u.key=i,e.emit("edgeAdded",u),i}function st(e,t,n,r,i,o,s,a,d){if(!r&&"undirected"===e.type)throw new ve(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(r&&"directed"===e.type)throw new ve(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a)if(d){if("function"!=typeof a)throw new we(`Graph.${t}: invalid updater function. Expecting a function but got "${a}"`)}else if(!pe(a))throw new we(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);let h;if(o=""+o,s=""+s,d&&(h=a,a=void 0),!e.allowSelfLoops&&o===s)throw new ve(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let u,c,p=e._nodes.get(o),l=e._nodes.get(s);if(!n&&(u=e._edges.get(i),u)){if(!(u.source.key===o&&u.target.key===s||r&&u.source.key===s&&u.target.key===o))throw new ve(`Graph.${t}: inconsistency detected when attempting to merge the "${i}" edge with "${o}" source & "${s}" target vs. ("${u.source.key}", "${u.target.key}").`);c=u}if(c||e.multi||!p||(c=r?p.undirected[s]:p.out[s]),c){const t=[c.key,!1,!1,!1];if(d?!h:!a)return t;if(d){const t=c.attributes;c.attributes=h(t),e.emit("edgeAttributesUpdated",{type:"replace",key:c.key,attributes:c.attributes})}else ue(c.attributes,a),e.emit("edgeAttributesUpdated",{type:"merge",key:c.key,attributes:c.attributes,data:a});return t}a=a||{},d&&h&&(a=h(a));const f={key:null,undirected:r,source:o,target:s,attributes:a};if(n)i=e._edgeKeyGenerator();else if(i=""+i,e._edges.has(i))throw new ve(`Graph.${t}: the "${i}" edge already exists in the graph.`);let g=!1,y=!1;p||(p=it(e,o,{}),g=!0,o===s&&(l=p,y=!0)),l||(l=it(e,s,{}),y=!0),u=new _e(r,i,p,l,a),e._edges.set(i,u);const b=o===s;return r?(p.undirectedDegree++,l.undirectedDegree++,b&&(p.undirectedLoops++,e._undirectedSelfLoopCount++)):(p.outDegree++,l.inDegree++,b&&(p.directedLoops++,e._directedSelfLoopCount++)),e.multi?u.attachMulti():u.attach(),r?e._undirectedSize++:e._directedSize++,f.key=i,e.emit("edgeAdded",f),[i,!0,g,y]}function at(e,t){e._edges.delete(t.key);const{source:n,target:r,attributes:i}=t,o=t.undirected,s=n===r;o?(n.undirectedDegree--,r.undirectedDegree--,s&&(n.undirectedLoops--,e._undirectedSelfLoopCount--)):(n.outDegree--,r.inDegree--,s&&(n.directedLoops--,e._directedSelfLoopCount--)),e.multi?t.detachMulti():t.detach(),o?e._undirectedSize--:e._directedSize--,e.emit("edgeDropped",{key:t.key,attributes:i,source:n.key,target:r.key,undirected:o})}class dt extends H.EventEmitter{constructor(e){if(super(),"boolean"!=typeof(e=ue({},rt,e)).multi)throw new we(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!tt.has(e.type))throw new we(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if("boolean"!=typeof e.allowSelfLoops)throw new we(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);fe(this,"NodeDataClass","mixed"===e.type?Ee:"directed"===e.type?ke:$e);const t="geid_"+et()+"_";let n=0;fe(this,"_attributes",{}),fe(this,"_nodes",new Map),fe(this,"_edges",new Map),fe(this,"_directedSize",0),fe(this,"_undirectedSize",0),fe(this,"_directedSelfLoopCount",0),fe(this,"_undirectedSelfLoopCount",0),fe(this,"_edgeKeyGenerator",(()=>{let e;do{e=t+n++}while(this._edges.has(e));return e})),fe(this,"_options",e),nt.forEach((e=>fe(this,e,this[e]))),ge(this,"order",(()=>this._nodes.size)),ge(this,"size",(()=>this._edges.size)),ge(this,"directedSize",(()=>this._directedSize)),ge(this,"undirectedSize",(()=>this._undirectedSize)),ge(this,"selfLoopCount",(()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount)),ge(this,"directedSelfLoopCount",(()=>this._directedSelfLoopCount)),ge(this,"undirectedSelfLoopCount",(()=>this._undirectedSelfLoopCount)),ge(this,"multi",this._options.multi),ge(this,"type",this._options.type),ge(this,"allowSelfLoops",this._options.allowSelfLoops),ge(this,"implementation",(()=>"graphology"))}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if("undirected"===this.type)return!1;if(1===arguments.length){const t=""+e,n=this._edges.get(t);return!!n&&!n.undirected}if(2===arguments.length){e=""+e,t=""+t;const n=this._nodes.get(e);return!!n&&n.out.hasOwnProperty(t)}throw new we(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if("directed"===this.type)return!1;if(1===arguments.length){const t=""+e,n=this._edges.get(t);return!!n&&n.undirected}if(2===arguments.length){e=""+e,t=""+t;const n=this._nodes.get(e);return!!n&&n.undirected.hasOwnProperty(t)}throw new we(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(1===arguments.length){const t=""+e;return this._edges.has(t)}if(2===arguments.length){e=""+e,t=""+t;const n=this._nodes.get(e);return!!n&&(void 0!==n.out&&n.out.hasOwnProperty(t)||void 0!==n.undirected&&n.undirected.hasOwnProperty(t))}throw new we(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if("undirected"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new ve("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const n=this._nodes.get(e);if(!n)throw new me(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new me(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const r=n.out&&n.out[t]||void 0;return r?r.key:void 0}undirectedEdge(e,t){if("directed"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new ve("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const n=this._nodes.get(e);if(!n)throw new me(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new me(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const r=n.undirected&&n.undirected[t]||void 0;return r?r.key:void 0}edge(e,t){if(this.multi)throw new ve("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new me(`Graph.edge: could not find the "${t}" target node in the graph.`);const r=n.out&&n.out[t]||n.undirected&&n.undirected[t]||void 0;if(r)return r.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in n.in||t in n.out)}areOutNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in n.out}areInNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in n.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return"directed"!==this.type&&t in n.undirected}areNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in n.in||t in n.out)||"directed"!==this.type&&t in n.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in n.in||"directed"!==this.type&&t in n.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in n.out||"directed"!==this.type&&t in n.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.inDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.outDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.inDegree),n}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.outDegree),n}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.degree: could not find the "${e}" node in the graph.`);let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.inDegree+t.outDegree),n}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree-2*t.directedLoops}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree-2*t.undirectedLoops}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return"directed"!==this.type&&(n+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.inDegree,r+=t.directedLoops),n-r}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return"directed"!==this.type&&(n+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.outDegree,r+=t.directedLoops),n-r}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let n=0,r=0;return"directed"!==this.type&&(n+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.inDegree+t.outDegree,r+=2*t.directedLoops),n-r}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new me(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new me(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new me(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const n=this._edges.get(t);if(!n)throw new me(`Graph.opposite: could not find the "${t}" edge in the graph.`);const r=n.source.key,i=n.target.key;if(e===r)return i;if(e===i)return r;throw new me(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${r}, ${i}).`)}hasExtremity(e,t){e=""+e,t=""+t;const n=this._edges.get(e);if(!n)throw new me(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return n.source.key===t||n.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new me(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new me(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new me(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return function(e,t,n){if(n&&!pe(n))throw new we(`Graph.addNode: invalid attributes. Expecting an object but got "${n}"`);if(t=""+t,n=n||{},e._nodes.has(t))throw new ve(`Graph.addNode: the "${t}" node already exist in the graph.`);const r=new e.NodeDataClass(t,n);return e._nodes.set(t,r),e.emit("nodeAdded",{key:t,attributes:n}),r}(this,e,t).key}mergeNode(e,t){if(t&&!pe(t))throw new we(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let n=this._nodes.get(e);return n?(t&&(ue(n.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:n.attributes,data:t})),[e,!1]):(n=new this.NodeDataClass(e,t),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&"function"!=typeof t)throw new we(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let n=this._nodes.get(e);if(n){if(t){const r=n.attributes;n.attributes=t(r),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:n.attributes})}return[e,!1]}const r=t?t({}):{};return n=new this.NodeDataClass(e,r),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:r}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.dropNode: could not find the "${e}" node in the graph.`);let n;if("undirected"!==this.type){for(const e in t.out){n=t.out[e];do{at(this,n),n=n.next}while(n)}for(const e in t.in){n=t.in[e];do{at(this,n),n=n.next}while(n)}}if("directed"!==this.type)for(const r in t.undirected){n=t.undirected[r];do{at(this,n),n=n.next}while(n)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const e=""+arguments[0],n=""+arguments[1];if(t=ce(this,e,n,this.type),!t)throw new me(`Graph.dropEdge: could not find the "${e}" -> "${n}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new me(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return at(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new ve("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new ve("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const n=ce(this,e=""+e,t=""+t,"directed");if(!n)throw new me(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return at(this,n),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new ve("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new ve("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const n=ce(this,e,t,"undirected");if(!n)throw new me(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return at(this,n),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),!0!==t.done;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if("function"!=typeof t)throw new we("Graph.updateAttribute: updater should be a function.");const n=this._attributes[e];return this._attributes[e]=t(n),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!pe(e))throw new we("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!pe(e))throw new we("Graph.mergeAttributes: provided attributes are not a plain object.");return ue(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if("function"!=typeof e)throw new we("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if("function"!=typeof e)throw new we("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!ye(t))throw new we("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._nodes.values();let r,i;for(;r=n.next(),!0!==r.done;)i=r.value,i.attributes=e(i.key,i.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if("function"!=typeof e)throw new we("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!ye(t))throw new we("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._edges.values();let r,i,o,s;for(;r=n.next(),!0!==r.done;)i=r.value,o=i.source,s=i.target,i.attributes=e(i.key,i.attributes,o.key,s.key,o.attributes,s.attributes,i.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if("function"!=typeof e)throw new we("Graph.forEachAdjacencyEntry: expecting a callback.");Xe(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new we("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");Xe(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if("function"!=typeof e)throw new we("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");Xe(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new we("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");Xe(!1,!0,!0,this,e)}nodes(){return"function"==typeof Array.from?Array.from(this._nodes.keys()):de(this._nodes.keys(),this._nodes.size)}forEachNode(e){if("function"!=typeof e)throw new we("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),!0!==n.done;)r=n.value,e(r.key,r.attributes)}findNode(e){if("function"!=typeof e)throw new we("Graph.findNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),!0!==n.done;)if(r=n.value,e(r.key,r.attributes))return r.key}mapNodes(e){if("function"!=typeof e)throw new we("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let n,r;const i=new Array(this.order);let o=0;for(;n=t.next(),!0!==n.done;)r=n.value,i[o++]=e(r.key,r.attributes);return i}someNode(e){if("function"!=typeof e)throw new we("Graph.someNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),!0!==n.done;)if(r=n.value,e(r.key,r.attributes))return!0;return!1}everyNode(e){if("function"!=typeof e)throw new we("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let n,r;for(;n=t.next(),!0!==n.done;)if(r=n.value,!e(r.key,r.attributes))return!1;return!0}filterNodes(e){if("function"!=typeof e)throw new we("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let n,r;const i=[];for(;n=t.next(),!0!==n.done;)r=n.value,e(r.key,r.attributes)&&i.push(r.key);return i}reduceNodes(e,t){if("function"!=typeof e)throw new we("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new we("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let n=t;const r=this._nodes.values();let i,o;for(;i=r.next(),!0!==i.done;)o=i.value,n=e(n,o.key,o.attributes);return n}nodeEntries(){const e=this._nodes.values();return new re((()=>{const t=e.next();if(t.done)return t;const n=t.value;return{value:{node:n.key,attributes:n.attributes},done:!1}}))}export(){const e=new Array(this._nodes.size);let t=0;this._nodes.forEach(((n,r)=>{e[t++]=function(e,t){const n={key:e};return le(t.attributes)||(n.attributes=ue({},t.attributes)),n}(r,n)}));const n=new Array(this._edges.size);return t=0,this._edges.forEach(((e,r)=>{n[t++]=function(e,t,n){const r={key:t,source:n.source.key,target:n.target.key};return le(n.attributes)||(r.attributes=ue({},n.attributes)),"mixed"===e&&n.undirected&&(r.undirected=!0),r}(this.type,r,e)})),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:n}}import(e,t=!1){if(e instanceof dt)return e.forEachNode(((e,n)=>{t?this.mergeNode(e,n):this.addNode(e,n)})),e.forEachEdge(((e,n,r,i,o,s,a)=>{t?a?this.mergeUndirectedEdgeWithKey(e,r,i,n):this.mergeDirectedEdgeWithKey(e,r,i,n):a?this.addUndirectedEdgeWithKey(e,r,i,n):this.addDirectedEdgeWithKey(e,r,i,n)})),this;if(!pe(e))throw new we("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!pe(e.attributes))throw new we("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let n,r,i,o,s;if(e.nodes){if(i=e.nodes,!Array.isArray(i))throw new we("Graph.import: invalid nodes. Expecting an array.");for(n=0,r=i.length;n<r;n++){o=i[n],Qe(o);const{key:e,attributes:r}=o;t?this.mergeNode(e,r):this.addNode(e,r)}}if(e.edges){let o=!1;if("undirected"===this.type&&(o=!0),i=e.edges,!Array.isArray(i))throw new we("Graph.import: invalid edges. Expecting an array.");for(n=0,r=i.length;n<r;n++){s=i[n],Ze(s);const{source:e,target:r,attributes:a,undirected:d=o}=s;let h;"key"in s?(h=t?d?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:d?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,h.call(this,s.key,e,r,a)):(h=t?d?this.mergeUndirectedEdge:this.mergeDirectedEdge:d?this.addUndirectedEdge:this.addDirectedEdge,h.call(this,e,r,a))}}return this}nullCopy(e){const t=new dt(ue({},this._options,e));return t.replaceAttributes(ue({},this.getAttributes())),t}emptyCopy(e){const t=this.nullCopy(e);return this._nodes.forEach(((e,n)=>{const r=ue({},e.attributes);e=new t.NodeDataClass(n,r),t._nodes.set(n,e)})),t}copy(e){if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new ve(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new ve("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new ve("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const t=this.emptyCopy(e),n=this._edges.values();let r,i;for(;r=n.next(),!0!==r.done;)i=r.value,ot(t,"copy",!1,i.undirected,i.key,i.source.key,i.target.key,ue({},i.attributes));return t}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach(((t,n)=>{e[n]=t.attributes}));const t={},n={};this._edges.forEach(((e,r)=>{const i=e.undirected?"--":"->";let o,s="",a=e.source.key,d=e.target.key;e.undirected&&a>d&&(o=a,a=d,d=o);const h=`(${a})${i}(${d})`;r.startsWith("geid_")?this.multi&&(void 0===n[h]?n[h]=0:n[h]++,s+=`${n[h]}. `):s+=`[${r}]: `,s+=h,t[s]=e.attributes}));const r={};for(const i in this)this.hasOwnProperty(i)&&!nt.has(i)&&"function"!=typeof this[i]&&"symbol"!=typeof i&&(r[i]=this[i]);return r.attributes=this._attributes,r.nodes=e,r.edges=t,fe(r,"constructor",this.constructor),r}}var ht;"undefined"!=typeof Symbol&&(dt.prototype[Symbol.for("nodejs.util.inspect.custom")]=dt.prototype.inspect),[{name:e=>`${e}Edge`,generateKey:!0},{name:e=>`${e}DirectedEdge`,generateKey:!0,type:"directed"},{name:e=>`${e}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:e=>`${e}EdgeWithKey`},{name:e=>`${e}DirectedEdgeWithKey`,type:"directed"},{name:e=>`${e}UndirectedEdgeWithKey`,type:"undirected"}].forEach((e=>{["add","merge","update"].forEach((t=>{const n=e.name(t),r="add"===t?ot:st;e.generateKey?dt.prototype[n]=function(i,o,s){return r(this,n,!0,"undirected"===(e.type||this.type),null,i,o,s,"update"===t)}:dt.prototype[n]=function(i,o,s,a){return r(this,n,!1,"undirected"===(e.type||this.type),i,o,s,a,"update"===t)}}))})),ht=dt,xe.forEach((function({name:e,attacher:t}){t(ht,e("Node"),0),t(ht,e("Source"),1),t(ht,e("Target"),2),t(ht,e("Opposite"),3)})),function(e){Ae.forEach((function({name:t,attacher:n}){n(e,t("Edge"),"mixed"),n(e,t("DirectedEdge"),"directed"),n(e,t("UndirectedEdge"),"undirected")}))}(dt),function(e){Me.forEach((t=>{!function(e,t){const{name:n,type:r,direction:i}=t;e.prototype[n]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];if(!arguments.length)return Oe(this,r);if(1===arguments.length){e=""+e;const t=this._nodes.get(e);if(void 0===t)throw new me(`Graph.${n}: could not find the "${e}" node in the graph.`);return Te(this.multi,"mixed"===r?this.type:r,i,t)}if(2===arguments.length){e=""+e,t=""+t;const o=this._nodes.get(e);if(!o)throw new me(`Graph.${n}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new me(`Graph.${n}:  could not find the "${t}" target node in the graph.`);return Ie(r,this.multi,i,o,t)}throw new we(`Graph.${n}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t,n){if("mixed"===r||"mixed"===this.type||r===this.type){if(1===arguments.length)return je(!1,this,r,n=e);if(2===arguments.length){e=""+e,n=t;const s=this._nodes.get(e);if(void 0===s)throw new me(`Graph.${o}: could not find the "${e}" node in the graph.`);return Pe(!1,this.multi,"mixed"===r?this.type:r,i,s,n)}if(3===arguments.length){e=""+e,t=""+t;const s=this._nodes.get(e);if(!s)throw new me(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new me(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return We(!1,r,this.multi,i,s,t,n)}throw new we(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const s="map"+n[0].toUpperCase()+n.slice(1);e.prototype[s]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();let n;if(0===e.length){let i=0;"directed"!==r&&(i+=this.undirectedSize),"undirected"!==r&&(i+=this.directedSize),n=new Array(i);let o=0;e.push(((e,r,i,s,a,d,h)=>{n[o++]=t(e,r,i,s,a,d,h)}))}else n=[],e.push(((e,r,i,o,s,a,d)=>{n.push(t(e,r,i,o,s,a,d))}));return this[o].apply(this,e),n};const a="filter"+n[0].toUpperCase()+n.slice(1);e.prototype[a]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop(),n=[];return e.push(((e,r,i,o,s,a,d)=>{t(e,r,i,o,s,a,d)&&n.push(e)})),this[o].apply(this,e),n};const d="reduce"+n[0].toUpperCase()+n.slice(1);e.prototype[d]=function(){let e,t,n=Array.prototype.slice.call(arguments);if(n.length<2||n.length>4)throw new we(`Graph.${d}: invalid number of arguments (expecting 2, 3 or 4 and got ${n.length}).`);if("function"==typeof n[n.length-1]&&"function"!=typeof n[n.length-2])throw new we(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);2===n.length?(e=n[0],t=n[1],n=[]):3===n.length?(e=n[1],t=n[2],n=[n[0]]):4===n.length&&(e=n[2],t=n[3],n=[n[0],n[1]]);let r=t;return n.push(((t,n,i,o,s,a,d)=>{r=e(r,t,n,i,o,s,a,d)})),this[o].apply(this,n),r}}(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o="find"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t,n){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return!1;if(1===arguments.length)return je(!0,this,r,n=e);if(2===arguments.length){e=""+e,n=t;const s=this._nodes.get(e);if(void 0===s)throw new me(`Graph.${o}: could not find the "${e}" node in the graph.`);return Pe(!0,this.multi,"mixed"===r?this.type:r,i,s,n)}if(3===arguments.length){e=""+e,t=""+t;const s=this._nodes.get(e);if(!s)throw new me(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new me(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return We(!0,r,this.multi,i,s,t,n)}throw new we(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const s="some"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[s]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();e.push(((e,n,r,i,o,s,a)=>t(e,n,r,i,o,s,a)));return!!this[o].apply(this,e)};const a="every"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[a]=function(){const e=Array.prototype.slice.call(arguments),t=e.pop();e.push(((e,n,r,i,o,s,a)=>!t(e,n,r,i,o,s,a)));return!this[o].apply(this,e)}}(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o=n.slice(0,-1)+"Entries";e.prototype[o]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return re.empty();if(!arguments.length)return ze(this,r);if(1===arguments.length){e=""+e;const t=this._nodes.get(e);if(!t)throw new me(`Graph.${o}: could not find the "${e}" node in the graph.`);return Re(r,i,t)}if(2===arguments.length){e=""+e,t=""+t;const n=this._nodes.get(e);if(!n)throw new me(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new me(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return Ke(r,i,n,t)}throw new we(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}(e,t)}))}(dt),function(e){He.forEach((t=>{Be(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return;e=""+e;const n=this._nodes.get(e);if(void 0===n)throw new me(`Graph.${o}: could not find the "${e}" node in the graph.`);Fe(!1,"mixed"===r?this.type:r,i,n,t)};const s="map"+n[0].toUpperCase()+n.slice(1);e.prototype[s]=function(e,t){const n=[];return this[o](e,((e,r)=>{n.push(t(e,r))})),n};const a="filter"+n[0].toUpperCase()+n.slice(1);e.prototype[a]=function(e,t){const n=[];return this[o](e,((e,r)=>{t(e,r)&&n.push(e)})),n};const d="reduce"+n[0].toUpperCase()+n.slice(1);e.prototype[d]=function(e,t,n){if(arguments.length<3)throw new we(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let r=n;return this[o](e,((e,n)=>{r=t(r,e,n)})),r}}(e,t),function(e,t){const{name:n,type:r,direction:i}=t,o=n[0].toUpperCase()+n.slice(1,-1),s="find"+o;e.prototype[s]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return;e=""+e;const n=this._nodes.get(e);if(void 0===n)throw new me(`Graph.${s}: could not find the "${e}" node in the graph.`);return Fe(!0,"mixed"===r?this.type:r,i,n,t)};const a="some"+o;e.prototype[a]=function(e,t){return!!this[s](e,t)};const d="every"+o;e.prototype[d]=function(e,t){return!this[s](e,((e,n)=>!t(e,n)))}}(e,t),Je(e,t)}))}(dt);class ut extends dt{constructor(e){const t=ue({type:"directed"},e);if("multi"in t&&!1!==t.multi)throw new we("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==t.type)throw new we('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class ct extends dt{constructor(e){const t=ue({type:"undirected"},e);if("multi"in t&&!1!==t.multi)throw new we("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==t.type)throw new we('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class pt extends dt{constructor(e){const t=ue({multi:!0},e);if("multi"in t&&!0!==t.multi)throw new we("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class lt extends dt{constructor(e){const t=ue({type:"directed",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new we("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==t.type)throw new we('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class ft extends dt{constructor(e){const t=ue({type:"undirected",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new we("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==t.type)throw new we('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function gt(e){e.from=function(t,n){const r=ue({},t.options,n),i=new e(r);return i.import(t),i}}gt(dt),gt(ut),gt(ct),gt(pt),gt(lt),gt(ft),dt.Graph=dt,dt.DirectedGraph=ut,dt.UndirectedGraph=ct,dt.MultiGraph=pt,dt.MultiDirectedGraph=lt,dt.MultiUndirectedGraph=ft,dt.InvalidArgumentsGraphError=we,dt.NotFoundGraphError=me,dt.UsageGraphError=ve;var yt=function(){function e(){this._events={}}return e.prototype.on=function(e,t,n){return this._events[e]||(this._events[e]=[]),this._events[e].push({callback:t,once:!!n}),this},e.prototype.once=function(e,t){return this.on(e,t,!0)},e.prototype.emit=function(e){for(var t=this,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];var i=this._events[e]||[],o=this._events["*"]||[],s=function(r){for(var i=r.length,o=0;o<i;o++)if(r[o]){var s=r[o],a=s.callback;s.once&&(r.splice(o,1),0===r.length&&delete t._events[e],i--,o--),a.apply(t,n)}};s(i),s(o)},e.prototype.off=function(e,t){if(e)if(t){for(var n=this._events[e]||[],r=n.length,i=0;i<r;i++)n[i].callback===t&&(n.splice(i,1),r--,i--);0===n.length&&delete this._events[e]}else delete this._events[e];else this._events={};return this},e.prototype.getEvents=function(){return this._events},e}();function bt(e,t,n,r){for(;e.length;){const i=e.shift();if(n(i))return!0;t.add(i.id),r(i.id).forEach((n=>{t.has(n.id)||(t.add(n.id),e.push(n))}))}return!1}function wt(e,t,n,r){if(n(e))return!0;t.add(e.id);for(const i of r(e.id))if(!t.has(i.id)&&wt(i,t,n,r))return!0;return!1}class mt extends yt{constructor(e){super(),n(this,"nodeMap",new Map),n(this,"edgeMap",new Map),n(this,"inEdgesMap",new Map),n(this,"outEdgesMap",new Map),n(this,"bothEdgesMap",new Map),n(this,"treeIndices",new Map),n(this,"changes",[]),n(this,"batchCount",0),n(this,"onChanged",(()=>{})),n(this,"batch",(e=>{this.batchCount+=1,e(),this.batchCount-=1,this.batchCount||this.commit()})),e&&(e.nodes&&this.addNodes(e.nodes),e.edges&&this.addEdges(e.edges),e.tree&&this.addTree(e.tree),e.onChanged&&(this.onChanged=e.onChanged))}commit(){const e=this.changes;this.changes=[];const t={graph:this,changes:e};this.emit("changed",t),this.onChanged(t)}reduceChanges(e){let t=[];return e.forEach((e=>{switch(e.type){case"NodeRemoved":{let n=!1;t=t.filter((t=>{if("NodeAdded"===t.type){const r=t.value.id===e.value.id;return r&&(n=!0),!r}return"NodeDataUpdated"===t.type?t.id!==e.value.id:"TreeStructureChanged"!==t.type||t.nodeId!==e.value.id})),n||t.push(e);break}case"EdgeRemoved":{let n=!1;t=t.filter((t=>{if("EdgeAdded"===t.type){const r=t.value.id===e.value.id;return r&&(n=!0),!r}return"EdgeDataUpdated"!==t.type&&"EdgeUpdated"!==t.type||t.id!==e.value.id})),n||t.push(e);break}case"NodeDataUpdated":case"EdgeDataUpdated":case"EdgeUpdated":{const n=t.find((t=>t.type===e.type&&t.id===e.id&&t.propertyName===e.propertyName));n?n.newValue=e.newValue:t.push(e);break}case"TreeStructureDetached":t=t.filter((t=>"TreeStructureAttached"===t.type?t.treeKey!==e.treeKey:"TreeStructureChanged"!==t.type||t.treeKey!==e.treeKey)),t.push(e);break;case"TreeStructureChanged":{const n=t.find((t=>"TreeStructureChanged"===t.type&&t.treeKey===e.treeKey&&t.nodeId===e.nodeId));n?n.newParentId=e.newParentId:t.push(e);break}default:t.push(e)}})),t}checkNodeExistence(e){this.getNode(e)}hasNode(e){return this.nodeMap.has(e)}areNeighbors(e,t){return this.getNeighbors(t).some((t=>t.id===e))}getNode(e){const t=this.nodeMap.get(e);if(!t)throw new Error("Node not found for id: "+e);return t}getRelatedEdges(e,t){if(this.checkNodeExistence(e),"in"===t){const t=this.inEdgesMap.get(e);return Array.from(t)}if("out"===t){const t=this.outEdgesMap.get(e);return Array.from(t)}{const t=this.bothEdgesMap.get(e);return Array.from(t)}}getDegree(e,t){return this.getRelatedEdges(e,t).length}getSuccessors(e){const t=this.getRelatedEdges(e,"out").map((e=>this.getNode(e.target)));return Array.from(new Set(t))}getPredecessors(e){const t=this.getRelatedEdges(e,"in").map((e=>this.getNode(e.source)));return Array.from(new Set(t))}getNeighbors(e){const t=this.getPredecessors(e),n=this.getSuccessors(e);return Array.from(new Set([...t,...n]))}doAddNode(e){if(this.hasNode(e.id))throw new Error("Node already exists: "+e.id);this.nodeMap.set(e.id,e),this.inEdgesMap.set(e.id,new Set),this.outEdgesMap.set(e.id,new Set),this.bothEdgesMap.set(e.id,new Set),this.treeIndices.forEach((t=>{t.childrenMap.set(e.id,new Set)})),this.changes.push({type:"NodeAdded",value:e})}addNodes(e){this.batch((()=>{for(const t of e)this.doAddNode(t)}))}addNode(e){this.addNodes([e])}doRemoveNode(e){const t=this.getNode(e),n=this.bothEdgesMap.get(e);null==n||n.forEach((e=>this.doRemoveEdge(e.id))),this.nodeMap.delete(e),this.treeIndices.forEach((t=>{var n;null==(n=t.childrenMap.get(e))||n.forEach((e=>{t.parentMap.delete(e.id)})),t.parentMap.delete(e),t.childrenMap.delete(e)})),this.changes.push({type:"NodeRemoved",value:t})}removeNodes(e){this.batch((()=>{e.forEach((e=>this.doRemoveNode(e)))}))}removeNode(e){this.removeNodes([e])}updateNodeDataProperty(e,t,n){const r=this.getNode(e);this.batch((()=>{const i=r.data[t],o=n;r.data[t]=o,this.changes.push({type:"NodeDataUpdated",id:e,propertyName:t,oldValue:i,newValue:o})}))}mergeNodeData(e,t){this.batch((()=>{Object.entries(t).forEach((([t,n])=>{this.updateNodeDataProperty(e,t,n)}))}))}updateNodeData(...e){const t=e[0],n=this.getNode(t);if("string"==typeof e[1])return void this.updateNodeDataProperty(t,e[1],e[2]);let r;if("function"==typeof e[1]){const t=e[1];r=t(n.data)}else"object"==typeof e[1]&&(r=e[1]);this.batch((()=>{const e=n.data,i=r;n.data=r,this.changes.push({type:"NodeDataUpdated",id:t,oldValue:e,newValue:i})}))}checkEdgeExistence(e){if(!this.hasEdge(e))throw new Error("Edge not found for id: "+e)}hasEdge(e){return this.edgeMap.has(e)}getEdge(e){return this.checkEdgeExistence(e),this.edgeMap.get(e)}getEdgeDetail(e){const t=this.getEdge(e);return{edge:t,source:this.getNode(t.source),target:this.getNode(t.target)}}doAddEdge(e){if(this.hasEdge(e.id))throw new Error("Edge already exists: "+e.id);this.checkNodeExistence(e.source),this.checkNodeExistence(e.target),this.edgeMap.set(e.id,e);const t=this.inEdgesMap.get(e.target),n=this.outEdgesMap.get(e.source),r=this.bothEdgesMap.get(e.source),i=this.bothEdgesMap.get(e.target);t.add(e),n.add(e),r.add(e),i.add(e),this.changes.push({type:"EdgeAdded",value:e})}addEdges(e){this.batch((()=>{for(const t of e)this.doAddEdge(t)}))}addEdge(e){this.addEdges([e])}doRemoveEdge(e){const t=this.getEdge(e),n=this.outEdgesMap.get(t.source),r=this.inEdgesMap.get(t.target),i=this.bothEdgesMap.get(t.source),o=this.bothEdgesMap.get(t.target);n.delete(t),r.delete(t),i.delete(t),o.delete(t),this.edgeMap.delete(e),this.changes.push({type:"EdgeRemoved",value:t})}removeEdges(e){this.batch((()=>{e.forEach((e=>this.doRemoveEdge(e)))}))}removeEdge(e){this.removeEdges([e])}updateEdgeSource(e,t){const n=this.getEdge(e);this.checkNodeExistence(t);const r=n.source,i=t;this.outEdgesMap.get(r).delete(n),this.bothEdgesMap.get(r).delete(n),this.outEdgesMap.get(i).add(n),this.bothEdgesMap.get(i).add(n),n.source=t,this.batch((()=>{this.changes.push({type:"EdgeUpdated",id:e,propertyName:"source",oldValue:r,newValue:i})}))}updateEdgeTarget(e,t){const n=this.getEdge(e);this.checkNodeExistence(t);const r=n.target,i=t;this.inEdgesMap.get(r).delete(n),this.bothEdgesMap.get(r).delete(n),this.inEdgesMap.get(i).add(n),this.bothEdgesMap.get(i).add(n),n.target=t,this.batch((()=>{this.changes.push({type:"EdgeUpdated",id:e,propertyName:"target",oldValue:r,newValue:i})}))}updateEdgeDataProperty(e,t,n){const r=this.getEdge(e);this.batch((()=>{const i=r.data[t],o=n;r.data[t]=o,this.changes.push({type:"EdgeDataUpdated",id:e,propertyName:t,oldValue:i,newValue:o})}))}updateEdgeData(...e){const t=e[0],n=this.getEdge(t);if("string"==typeof e[1])return void this.updateEdgeDataProperty(t,e[1],e[2]);let r;if("function"==typeof e[1]){const t=e[1];r=t(n.data)}else"object"==typeof e[1]&&(r=e[1]);this.batch((()=>{const e=n.data,i=r;n.data=r,this.changes.push({type:"EdgeDataUpdated",id:t,oldValue:e,newValue:i})}))}mergeEdgeData(e,t){this.batch((()=>{Object.entries(t).forEach((([t,n])=>{this.updateEdgeDataProperty(e,t,n)}))}))}checkTreeExistence(e){if(!this.hasTreeStructure(e))throw new Error("Tree structure not found for treeKey: "+e)}hasTreeStructure(e){return this.treeIndices.has(e)}attachTreeStructure(e){this.treeIndices.has(e)||(this.treeIndices.set(e,{parentMap:new Map,childrenMap:new Map}),this.batch((()=>{this.changes.push({type:"TreeStructureAttached",treeKey:e})})))}detachTreeStructure(e){this.checkTreeExistence(e),this.treeIndices.delete(e),this.batch((()=>{this.changes.push({type:"TreeStructureDetached",treeKey:e})}))}addTree(e,t){this.batch((()=>{this.attachTreeStructure(t);const n=[],r=Array.isArray(e)?e:[e];for(;r.length;){const e=r.shift();n.push(e),e.children&&r.push(...e.children)}this.addNodes(n),n.forEach((e=>{var n;null==(n=e.children)||n.forEach((n=>{this.setParent(n.id,e.id,t)}))}))}))}getRoots(e){return this.checkTreeExistence(e),this.getAllNodes().filter((t=>!this.getParent(t.id,e)))}getChildren(e,t){this.checkNodeExistence(e),this.checkTreeExistence(t);const n=this.treeIndices.get(t).childrenMap.get(e);return Array.from(n||[])}getParent(e,t){this.checkNodeExistence(e),this.checkTreeExistence(t);return this.treeIndices.get(t).parentMap.get(e)||null}getAncestors(e,t){const n=[];let r,i=this.getNode(e);for(;r=this.getParent(i.id,t);)n.push(r),i=r;return n}setParent(e,t,n){var r;this.checkTreeExistence(n);const i=this.treeIndices.get(n),o=this.getNode(e),s=i.parentMap.get(e),a=this.getNode(t);i.parentMap.set(e,a),s&&(null==(r=i.childrenMap.get(s.id))||r.delete(o));let d=i.childrenMap.get(a.id);d||(d=new Set,i.childrenMap.set(a.id,d)),d.add(o),this.batch((()=>{this.changes.push({type:"TreeStructureChanged",treeKey:n,nodeId:e,oldParentId:null==s?void 0:s.id,newParentId:a.id})}))}dfsTree(e,t,n){return wt(this.getNode(e),new Set,t,(e=>this.getChildren(e,n)))}bfsTree(e,t,n){return bt([this.getNode(e)],new Set,t,(e=>this.getChildren(e,n)))}getAllNodes(){return Array.from(this.nodeMap.values())}getAllEdges(){return Array.from(this.edgeMap.values())}bfs(e,t,n="out"){const r={in:this.getPredecessors.bind(this),out:this.getSuccessors.bind(this),both:this.getNeighbors.bind(this)}[n];return bt([this.getNode(e)],new Set,t,r)}dfs(e,t,n="out"){const r={in:this.getPredecessors.bind(this),out:this.getSuccessors.bind(this),both:this.getNeighbors.bind(this)}[n];return wt(this.getNode(e),new Set,t,r)}clone(){const e=this.getAllNodes().map((e=>t(t({},e),{data:t({},e.data)}))),n=this.getAllEdges().map((e=>t(t({},e),{data:t({},e.data)}))),r=new mt({nodes:e,edges:n});return this.treeIndices.forEach((({parentMap:e,childrenMap:t},n)=>{const i=new Map;e.forEach(((e,t)=>{i.set(t,r.getNode(e.id))}));const o=new Map;t.forEach(((e,t)=>{o.set(t,new Set(Array.from(e).map((e=>r.getNode(e.id)))))})),r.treeIndices.set(n,{parentMap:i,childrenMap:o})})),r}toJSON(){return JSON.stringify({nodes:this.getAllNodes(),edges:this.getAllEdges()})}}var vt=function(e){if(!r(e))throw new Error("graphology-metrics/simple-size: the given graph is not a valid graphology instance.");if(!e.multi)return e.size;var t=0,n=0;function i(){t++}function o(){n++}return e.forEachNode((function(t){"directed"!==e.type&&e.forEachUndirectedNeighbor(t,i),"undirected"!==e.type&&e.forEachOutNeighbor(t,o)})),t/2+n};function Et(e,t){return 2*t/(e*(e-1))}function kt(e,t){return t/(e*(e-1))}function $t(e,t){var n=e*(e-1);return t/(n+n/2)}function _t(e,t,n){var i,o;if(arguments.length>3){if(o=arguments[3],"number"!=typeof(i=n)||i<0)throw new Error("graphology-metrics/density: given order is not a valid number.");if("number"!=typeof o||o<0)throw new Error("graphology-metrics/density: given size is not a valid number.")}else{if(!r(n))throw new Error("graphology-metrics/density: given graph is not a valid graphology instance.");i=n.order,o=n.size,n.multi&&!1===t&&(o=vt(n))}return i<2?0:(null===e&&(e=n.type),null===t&&(t=n.multi),("undirected"===e?Et:"directed"===e?kt:$t)(i,o))}_t.bind(null,null,null),_t.bind(null,"directed",!1),_t.bind(null,"undirected",!1),_t.bind(null,"mixed",!1),_t.bind(null,"directed",!0),_t.bind(null,"undirected",!0),_t.bind(null,"mixed",!0);var Gt=function(e,t){if(null===(n=e)||"function"!=typeof n||"object"!=typeof n.prototype||"function"!=typeof n.prototype.addUndirectedEdgeWithKey||"function"!=typeof n.prototype.dropNode)throw new Error("graphology-generators/random/clusters: invalid Graph constructor.");var n,r="clusterDensity"in(t=t||{})?t.clusterDensity:.5,i=t.rng||Math.random,o=t.order,s=t.size,a=t.clusters;if("number"!=typeof r||r>1||r<0)throw new Error("graphology-generators/random/clusters: `clusterDensity` option should be a number between 0 and 1.");if("function"!=typeof i)throw new Error("graphology-generators/random/clusters: `rng` option should be a function.");if("number"!=typeof o||o<=0)throw new Error("graphology-generators/random/clusters: `order` option should be a positive number.");if("number"!=typeof s||s<=0)throw new Error("graphology-generators/random/clusters: `size` option should be a positive number.");if("number"!=typeof a||a<=0)throw new Error("graphology-generators/random/clusters: `clusters` option should be a positive number.");var d=new e;if(!o)return d;var h,u,c,p,l,f,g=new Array(a);for(c=0;c<a;c++)g[c]=[];for(c=0;c<o;c++)h=i()*a|0,d.addNode(c,{cluster:h}),g[h].push(c);if(!s)return d;for(c=0;c<s;c++){if(i()<1-r){p=i()*o|0;do{l=i()*o|0}while(p===l)}else{if(!(f=(u=g[h=i()*a|0]).length)||f<2)continue;p=u[i()*f|0];do{l=u[i()*f|0]}while(p===l)}d.multi?d.addEdge(p,l):d.mergeEdge(p,l)}return d};export{mt as G,b as _,w as a,m as b,Gt as c,dt as d,y as g,T as i,M as w};
