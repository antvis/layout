import Graph from "graphology";
import { clusters } from "graphology-generators/random";
import { CANVAS_SIZE, TestName } from "./types";

export const loadDatasets = async () => {
  const datasets: Record<any, any> = {};

  const loadRandomClusters = () => {
    const NODES = 1000;
    const EDGES = 2000;

    // Use graphology generator.
    const graph = clusters(Graph, {
      order: NODES,
      size: EDGES,
      clusters: 5,
    });
    graph.edges().forEach(function (edge, i) {
      // graph.setEdgeAttribute(edge, "weight", i > EDGES / 2 ? 1 : 100);
      graph.setEdgeAttribute(edge, "weight", 1);
    });
    graph.nodes().forEach(function (node) {
      graph.setNodeAttribute(node, "x", Math.random() * CANVAS_SIZE);
      graph.setNodeAttribute(node, "y", Math.random() * CANVAS_SIZE);
    });

    const antvgraph = graphology2antv(graph);
    const antvgraphWASM = graphology2antv_wasm(graph);

    return {
      desc: "Creates a graph with the desired number of nodes & edges and having a given number of clusters. Generated by Graphology Generators.",
      [TestName.GRAPHOLOGY]: graph,
      [TestName.ANTV_LAYOUT]: antvgraph,
      [TestName.ANTV_LAYOUT_GPU]: antvgraph,
      [TestName.ANTV_LAYOUT_WASM_SINGLETHREAD]: antvgraphWASM,
      [TestName.ANTV_LAYOUT_WASM_MULTITHREADS]: antvgraphWASM,
    };
  };

  const loadG6JSON = (url: string, desc: string) => {
    return async () => {
      const result = await fetch(url);
      const antvGraphModel = await result.json();

      // assign random positions
      antvGraphModel.nodes.forEach((node: any) => {
        if (node.x === undefined) {
          node.x = Math.random() * CANVAS_SIZE;
        }
        if (node.y === undefined) {
          node.y = Math.random() * CANVAS_SIZE;
        }
      });
      antvGraphModel.edges.forEach((edge: any) => {
        if (edge.weight === undefined || edge.weight === null) {
          edge.weight = 1;
        } else {
          edge.weight = Number(edge.weight);
        }
      });

      const graphlibModel = antv2graphology(antvGraphModel);
      const graphWASM = graphology2antv_wasm(graphlibModel);
      return {
        desc,
        [TestName.GRAPHOLOGY]: graphlibModel,
        [TestName.ANTV_LAYOUT]: antvGraphModel,
        [TestName.ANTV_LAYOUT_GPU]: antvGraphModel,
        [TestName.ANTV_LAYOUT_WASM_SINGLETHREAD]: graphWASM,
        [TestName.ANTV_LAYOUT_WASM_MULTITHREADS]: graphWASM,
      };
    };
  };

  const [randomClusters, relations, netscience, eva, regions] =
    await Promise.all([
      loadRandomClusters(),
      loadG6JSON(
        "https://gw.alipayobjects.com/os/antvdemo/assets/data/relations.json",
        'A small dataset of "relations" between people.'
      )(),
      loadG6JSON(
        "https://gw.alipayobjects.com/os/basement_prod/da5a1b47-37d6-44d7-8d10-f3e046dabf82.json",
        "Netscience with 1589 nodes & 2742 edges."
      )(),
      loadG6JSON(
        "https://gw.alipayobjects.com/os/basement_prod/0b9730ff-0850-46ff-84d0-1d4afecd43e6.json",
        "Eva with 8322 nodes & 5421 edges."
      )(),
      loadG6JSON(
        "https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json",
        "A dataset for regions on earth."
      )(),
    ]);

  datasets["random-clusters"] = randomClusters;
  datasets.relations = relations;
  datasets.netscience = netscience;
  datasets.eva = eva;
  datasets.regions = regions;

  return datasets;
};

const graphology2antv = (graph: any) => {
  return {
    nodes: graph.nodes().map((id: any) => ({
      id: id,
      x: graph.getNodeAttribute(id, "x"),
      y: graph.getNodeAttribute(id, "y"),
    })),
    edges: graph.edges().map((id: any) => ({
      source: graph.source(id),
      target: graph.target(id),
      weight: graph.getEdgeAttribute(id, "weight"),
    })),
  };
};

const antv2graphology = ({ nodes, edges }: any) => {
  const g = new Graph();
  nodes.forEach(({ id, x, y }: any) => {
    if (!g.hasNode(id)) {
      g.addNode(id, { x, y });
    }
  });
  edges.forEach(({ source, target, weight }: any) => {
    g.addEdge(source, target, { weight });
  });
  return g;
};

const graphology2antv_wasm = (graph: any) => {
  const nodes: number[] = [];
  const masses: number[] = [];
  const edges: number[][] = [];
  const weights: number[] = [];
  const nodeIdxMap: Record<string, number> = {};
  graph.nodes().forEach((id: string, i: number) => {
    nodeIdxMap[id] = i;
    nodes.push(
      graph.getNodeAttribute(id, "x"),
      graph.getNodeAttribute(id, "y")
    );
    masses.push(1);
  });
  graph.edges().forEach((id: any) => {
    const weight = graph.getEdgeAttribute(id, "weight");
    const source = nodeIdxMap[graph.source(id)];
    const target = nodeIdxMap[graph.target(id)];

    if (source !== undefined && target !== undefined) {
      // n1 <- n2
      edges.push([target, source]);
      weights.push(weight);
      // @see https://github.com/graphology/graphology/blob/master/src/layout-forceatlas2/helpers.js#L156-L158
      masses[source] += weight;
      masses[target] += weight;
    }
  });

  return {
    nodes,
    masses,
    edges,
    weights,
  };
};
